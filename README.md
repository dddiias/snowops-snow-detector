# Snow Detector

Сервис читает RTSP-видеопоток, детектирует грузовики моделью YOLOv8n и по проходу через центральный коридор делает снимок. Снимок анализируется в Google Gemini (`gemini-2.5-flash`) для оценки заполнения кузова снегом. Результат сохраняется локально и отправляется на backend SnowOps в виде multipart-запроса с JSON и фото.

## Требования
- Python 3.10+.
- FFmpeg в PATH (желательно для стабильной работы `opencv-python` с RTSP).
- Файл весов `yolov8n.pt` рядом с `main.py` (присутствует в репозитории).
- Переменная окружения `GEMINI_API_KEY` (проверяется при старте).

## Установка
```bash
python -m venv .venv
.\.venv\Scripts\activate   # Linux/macOS: source .venv/bin/activate
pip install -r requirements.txt
```

## Настройка
1) Скопируйте `sample_env` в `.env`.
2) Пропишите ключ: `GEMINI_API_KEY=<ваш_ключ>`.
3) При необходимости поправьте параметры в `main.py`:
   - `VIDEO_SOURCE_URL` — RTSP-URL камеры.
   - `CENTER_ZONE_START_X` / `CENTER_ZONE_END_X` / `CENTER_LINE_X` — доли ширины кадра, задающие центральный коридор.
   - `MIN_DIRECTION_DELTA` — минимальный сдвиг по X, чтобы считать движение вправо.
   - `CONFIDENCE_THRESHOLD`, `TRUCK_CLASS_ID` — пороги детекции.
   - `SNAPSHOT_BASE_DIR` — куда сохранять снимки и JSON.
   - `BACKEND_ENDPOINT`, `CAMERA_ID` — адрес и идентификатор камеры для отправки события.
   - `GEMINI_MODEL` — модель Gemini.

## Запуск
```bash
python main.py
```
Окно OpenCV закроется по `q` или `Esc`. После 50 подряд неудачных чтений поток переподключается.

## Как работает
- Читает кадры из `VIDEO_SOURCE_URL`.
- YOLOv8n ищет грузовики; берётся крупнейший бокс с доверием выше порога.
- Проверяется движение слева направо (`MIN_DIRECTION_DELTA`) и попадание центра бокса в центральный коридор (`CENTER_ZONE_START_X..END_X`).
- При первом срабатывании для текущего грузовика (флаг `event_sent_for_current_truck`):
  - сохраняет «сырой» кадр в `snapshots/YYYY-MM-DD/HH-MM-SS.jpg`;
  - отправляет кадр в Gemini, ожидая JSON вида `{percentage, confidence}`; если распарсить не удалось — сохраняется `{"raw": "<ответ>"}`;
  - пишет результат рядом в `snapshots/.../HH-MM-SS.json` с `timestamp`, `image_path`, `gemini`;
  - отправляет событие на `BACKEND_ENDPOINT` (multipart/form-data): поле `event` с JSON (`camera_id`, `event_time`, `snow_volume_percentage`, `snow_volume_confidence`) и файлы `photos` с кадром.
- В окне рисуются направляющие линии и бокс детекции.
- Когда объект пропадает, флаг сбрасывается, и следующий грузовик снова даст одно срабатывание.

## Особенности и ограничения
- Логика заточена под движение слева направо; для обратного направления измените `is_moving_left_to_right` и границы коридора.
- `_last_center_x` сбрасывается только при потере объекта; если поток пропадает, возможны редкие ложные «не движется вправо».
- Отправляется один event на проход (пока грузовик виден). Новая серия появится после потери/возврата объекта.
- Некоторые строки логов можно привести к UTF-8 для читаемости — на работу не влияет.

## Быстрый чек
1) Активируйте venv, установите зависимости.
2) Создайте `.env` с `GEMINI_API_KEY`.
3) Проверьте доступность RTSP-URL.
4) Запустите `python main.py`; дождитесь появления грузовика в коридоре — в `snapshots/<дата>/` появятся `.jpg` и `.json`, а в консоли — ответ Gemini и статус отправки на backend.
